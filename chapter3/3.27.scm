(define (make-table same-key?)
  (display "MAKING TABLE")
  (define local-table (list '*table*))
  (define (assoc key records)
    (cond ((null? records) #f)
          ((same-key? key (caar records)) (car records))
          (else (assoc key (cdr records)))))
  (define (assoc1 key set-of-records)
    (cond ((null? set-of-records) #f)
          ((same-key? key (car )))))
  (define (lookup table)
    (lambda (keys)
      (if (null? keys) 
          #f
          (let ((record (assoc (car keys) (cdr table)))
                (rest-of-keys (cdr keys)))
            (cond ((eq? record #f) #f)
                  ((null? rest-of-keys) (cdr record))
                  (else ((lookup record) rest-of-keys)))))))
  (define (insert! table)
    (lambda (keys value)
      (if (null? keys) (error "No keys -- INSERT!"))
      (define current-key (car keys))
      (define rest-of-keys (cdr keys))
      (define records (cdr table))
      (define record (assoc current-key records)) ;Record we are searching for
      (if record
          (cond ((null? rest-of-keys)
                 (set-cdr! record value))
                (else (if (not (list? (cdr record))) ;Need correct check if record value is not another table
                          (set-cdr! record (list)))
                      ((insert! record) rest-of-keys value)))
          (cond ((null? rest-of-keys)
                 (set-cdr! table
                           (cons (cons current-key value)
                                 records)))
                (else (set-cdr! table
                                (cons (list current-key) records))
                      ((insert! (cadr table)) rest-of-keys value))))))
  (define (print) 
    (define (indent tabs) 
      (for-each (lambda (x) (display #\tab)) (iota tabs))) 
  
    (define (print-record rec level) 
      (indent level) 
      (display (car rec)) 
      (display ": ") 
      (if (list? rec) 
          (begin (newline) 
                 (print-table rec (1+ level))) 
                 (begin (display (cdr rec)) 
                        (newline)))) 
              
      (define (print-table table level) 
        (if (null? (cdr table)) 
            (begin (display "-no entries-") 
                   (newline)) 
            (for-each (lambda (record) 
                        (print-record record level)) 
                        (cdr table)))) 
      (newline)
      (print-table local-table 0)) 
  (define (dispatch m)
    (cond ((eq? m 'lookup-proc) (lookup local-table))
          ((eq? m 'insert-proc!) (insert! local-table))
          ((eq? m 'print) (print))
          (else (error "Unknown operation -- TABLE" m))))
  dispatch)

(define (memoize f)
  (let ((table (make-table equal?)))
    (lambda (x)
      (display "x: ")
      (display x)
      (table 'print)
      (let ((previously-computed-result ((table 'lookup-proc) (list x))))
        (or previously-computed-result
            (let ((result (f x)))
              ((table 'insert-proc!) (list x) result)
              result))))))

(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
        
(memo-fib 3)