(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
   (define (set-my-value newval setter)
     (cond ((not (has-value? me))
            (set! value newval)
            (set! informant setter)
            (for-each-except setter
                             inform-about-value
                             constraints))
           ((not (= value newval))
            (error "Contradiction" (list value newval)))
           (else 'ignored)))
   (define (forget-my-value retractor)
     (if (eq? retractor informant)
         (begin (set! informant false)
                (for-each-except retractor
                                 inform-about-no-value
                                 constraints))
         'ignored))
   (define (connect new-constraint)
     (if (not (memq new-constraint constraints))
         (set! constraints
           (cons new-constraint constraints)))
     (if (has-value? me)
         (inform-about-value new-constraint))
     'done)
   (define (me request)
     (cond ((eq? request 'has-value?)
            (if informant true false))
           ((eq? request 'value) value)
           ((eq? request 'set-value!) set-my-value)
           ((eq? request 'forget) forget-my-value)
           ((eq? request 'connect) connect)
           (else (error "Unknown operation: CONNECTOR"
                        request))))
   me))

(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))

(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))

(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))

(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))

(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
       (first-item)
       (remove-first-agenda-item! the-agenda)
       (propagate))))

(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))

(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))
(define (empty-agenda? agenda)
  (null? (segments agenda)))

(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
     (insert-queue! q action)
     (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
         (if (belongs-before? rest)
             (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
             (add-to-segments! rest)))))
  ((connector 'connect) new-constraint))

