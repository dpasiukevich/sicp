(define (make-accumulator value)
  (lambda (x)
    (begin (set! value (+ value x))
           value)))

(define (make-monitored func)
  (let ((count 0))
   (lambda (arg)
     (cond ((eqv? arg 'how-many-calls?) count)
           ((eqv? arg 'reset-count) (begin (set! count 0) count))
           (else (begin (set! count (+ count 1))
                        (func arg)))))))

(define (make-account balance password)
  (define incorrect-password-limit 3)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (make-secured func password)
    (let ((incorrect-pass-count 0))
     (lambda (p m)
       (if (eqv? p password)
           (begin (set! incorrect-pass-count 0)
                  (func m))
           (if (= incorrect-pass-count incorrect-password-limit)
               (lambda (m) "cops were called, buddy")
               (begin (set! incorrect-pass-count (+ 1 incorrect-pass-count))
                      (lambda (m) "Incorrect password")))))))
  (define (make-joined new-password) (make-secured dispatch new-password))
  (define (dispatch m)
    (cond ((eqv? m 'withdraw) withdraw)
          ((eqv? m 'deposit) deposit)
          ((eqv? m 'make-joint) make-joined)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  (make-secured dispatch password))

(define (make-joint acc pass new-pass) ((acc pass 'make-joint) new-pass))

(define peter-acc (make-account 100 'open-sesame))
((peter-acc 'open-sesame 'withdraw) 10)
(define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))
((paul-acc 'open-sesame 'withdraw) 5) ; error - wrong pass
((paul-acc 'rosebud 'withdraw) 5) ; res should be 85

(define (random-in-range low high)
  (let ((range (- high low)))
   (+ low (random range))))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1)
                 (+ trials-passed 1)))
          (else (iter (- trials-remaining 1)
                      trials-passed))))
  (iter trials 0))

(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test)))) 
(define (cesaro-test)
  (= (gcd (rand) (rand)) 1)) 

(define (estimate-integral P x1 y1 x2 y2 trials)
  (* (monte-carlo trials (lambda () (P (random-in-range x1 x2)
                                       (random-in-range y1 y2))))
     (* (- y2 y1) (- x2 x1))))
(define (P x y)
  (< (+ (expt (- x 5) 2)
        (expt (- y 7) 2))
     (expt 3 2)))

(define pi-approx
  (/ (estimate-integral P 2.0 4.0 8.0 10.0 1000000)
     9.0))

(define (make-random value)
  (define (new-rand x) (remainder (+ (* 14234324234234 x) 2892923) 10000))
  (define (reset new) (set! value new) new)
  (lambda (m)
    (cond ((eqv? m 'generate) (begin (set! value (new-rand value)) value))
          ((eqv? m 'reset) reset)
          (else (error "Unknown request -- RAND" m)))))

(define f
  (let ((state 0))
   (lambda (x)
     (let ((old-state state))
      (set! state x)
      old-state))))

(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y (
           let ((temp (cdr x)))
           (set-cdr! x y)
           (loop temp x))))
  (loop x '()))

(define (count-pairs pairs)
  (define visited (make-eq-hash-table))
  (define (iter pair)
    (cond ((not (pair? pair)) 0)
          ((hash-table-ref/default visited pair #f) 0)
          (else (hash-table-set! visited pair #t)
                (+ 1
                   (iter (car pair))
                   (iter (cdr pair))))))
  (iter pairs))

(count-pairs (cons (cons 1 2) (cons 3 2)))
(count-pairs (cons (cons (cons 1 2) 2) (cons 3 2)))

(define x (cons 1 2))
(set-cdr! x x)

(count-pairs x)
