(define (make-tree eq lt gt)
  (define tree '())
  (define (new-tree entry left right) (list entry left right))
  (define (entry tree) (car tree))
  (define (left-branch tree) (cadr tree))
  (define (right-branch tree) (caddr tree))
  (define (element-of-tree? el tree)
    (cond ((null? tree) #f)
          ((eq el (entry tree)) #t)
          ((lt el (entry tree)) (element-of-tree? el (left-branch tree)))
          ((gt el (entry tree)) (element-of-tree? el (right-branch tree)))))
  (define (insert el tree)
    (cond ((null? tree) (new-tree el '() '()))
          ((eq el (entry tree)) tree)
          ((lt el (entry tree))
           (new-tree (entry tree)
                     (insert el (left-branch tree))
                     (right-branch tree)))
          ((gt el (entry tree))
           (new-tree (entry tree)
                     (left-branch tree)
                     (insert el (right-branch tree))))))
  (define (dispatch m)
    (cond ((eq? m 'insert) (lambda (el) (set! tree (insert el tree))))
          ((eq? m 'print) tree)
          (else (error "Operation is not supported -- TREE" m))))
  dispatch)

(define (make-table same-key?)
  (define (init-table key records) (cons (list key) records))
  (define local-table (init-table '*table* '()))
  (define (assoc key records)
    (cond ((null? records) #f)
          ((same-key? key (caar records)) (car records))
          (else (assoc key (cdr records)))))
  (define (lookup table)
    (lambda (keys)
      (if (null? keys) 
          #f
          (let ((record (assoc (car keys) (cdr table)))
                (rest-of-keys (cdr keys)))
            (cond ((eq? record #f) #f)
                  ((null? rest-of-keys) (cdr record))
                  (else ((lookup record) rest-of-keys)))))))
  (define (insert! table)
    (lambda (keys value)
      (if (null? keys) (error "No keys -- INSERT!"))
      (define current-key (car keys))
      (define rest-of-keys (cdr keys))
      (define records (cdr table))
      (define record (assoc current-key records))
      (if record
          (cond ((null? rest-of-keys)
                 (set-cdr! record value))
                (else (if (not (list? (cdr record))) ;Need correct check if record value is not another table
                          (set-cdr! record '()))
                      ((insert! record) rest-of-keys value)))
          (cond ((null? rest-of-keys)
                 (set-cdr! table
                           (cons (cons current-key value)
                                 records)))
                (else (set-cdr! table (init-table current-key records))
                      ((insert! (cadr table)) rest-of-keys value))))))
  (define (print) 
    (define (indent tabs) 
      (for-each (lambda (x) (display #\tab)) (iota tabs))) 
    (define (print-record rec level) 
      (indent level) 
      (display (car rec)) 
      (display ": ") 
      (if (list? rec) 
          (begin (newline) 
                 (print-table rec (1+ level))) 
                 (begin (display (cdr rec)) 
                        (newline))))         
      (define (print-table table level) 
        (if (null? (cdr table)) 
            (begin (display "-no entries-") 
                   (newline)) 
            (for-each (lambda (record) 
                        (print-record record level)) 
                        (cdr table)))) 
      (newline)
      (print-table local-table 0)) 
  (define (dispatch m)
    (cond ((eq? m 'lookup-proc) (lookup local-table))
          ((eq? m 'insert-proc!) (insert! local-table))
          ((eq? m 'print) (print))
          (else (error "Unknown operation -- TABLE" m))))
  dispatch)

(define operation-table (make-table eq?))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(define t (make-table equal?))
((t 'insert-proc!) (list 1 2) 'test-value)
((t 'insert-proc!) (list 1 3 2 4) 'lul)
((t 'insert-proc!) (list 1 2 3) 'lul1)
((t 'lookup-proc) (list 1 2))
((t 'lookup-proc) (list 1))
((t 'insert-proc!) (list 2) 2)
((t 'insert-proc!) (list 2 3) 14)
((t 'insert-proc!) (list 2 2) 14)
((t 'insert-proc!) (list 1 2) 14)
((t 'insert-proc!) (list 1) 14)
((t 'insert-proc!) (list 1 2 3 4) 14)

(t 'print)

(define t (make-tree = < >))
((t 'insert) 5)
((t 'insert) 1)
((t 'insert) 7)
((t 'insert) 9)
((t 'insert) 2)
(t 'print)
