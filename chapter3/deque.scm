(define (make-deque)
  ; internal funcs
  (define (split-pair! pair)
    (let ((last (cdr pair)))
     (set-cdr! pair ())
     last))
  (define (split-list! L)
    (define (iter L cur)
      (if (= cur 0)
          (split-pair! L)
          (iter (cdr L) (- cur 1))))
    (if (< (length L) 2)
        L
        (iter L (quotient (- (length L) 1) 2))))
  (define (rebalance-from source target)
    (define (rebalance-helper S T)
      (cond ((or (> (length T) 0)
                 (= (length S) 0))
             (error "incorrect rebalance call. source must be non-nil and target must be nil, got source: " source " target: " target))
            ((= (length S) 1) (cons T S))
            (else (cons S (split-list! S)))))
    (let ((rebalance-result (rebalance-helper source target)))
     (cond ((eq? source front-list)
            (set! front-list (car rebalance-result))
            (set! rear-list (cdr rebalance-result)))
           (else (set! rear-list (car rebalance-result))
                 (set! front-list (cdr rebalance-result))))))
  ; funcs implementing external API
  (define front-list ())
  (define rear-list ())
  (define (empty-deque?) (and (null? front-list) (null? rear-list)))
  (define (front-insert-deque! item)
    (set! front-list (cons item front-list)))
  (define (rear-insert-deque! item)
    (set! rear-list (cons item rear-list)))
  (define (front-deque)
    (cond ((empty-deque?) (error "deque is empty"))
          ((null? front-list) (rebalance-from rear-list front-list) (car front-list))
          (else (car front-list))))
  (define (rear-deque)
    (cond ((empty-deque?) (error "deque is empty"))
          ((null? rear-list) (rebalance-from front-list rear-list) (car rear-list))
          (else (car rear-list))))
  (define (front-delete-deque!)
    (cond ((empty-deque?) (error "deque is empty"))
          ((null? front-list) (rebalance-from rear-list front-list) (front-delete-deque!))
          (else (let ((val (car front-list)))
                 (set! front-list (cdr front-list))
                 val))))
  (define (rear-delete-deque!)
    (cond ((empty-deque?) (error "deque is empty"))
          ((null? rear-list) (rebalance-from front-list rear-list) (rear-delete-deque!))
          (else (let ((val (car rear-list)))
                 (set! rear-list (cdr rear-list))
                 val))))
  (define (display-deque) (display (append front-list (reverse rear-list))))
  (define (dispatch m)
    (cond ((eq? m 'empty-deque?) (empty-deque?))
          ((eq? m 'front-deque) (front-deque))
          ((eq? m 'rear-deque) (rear-deque))
          ((eq? m 'front-insert-deque!) front-insert-deque!)
          ((eq? m 'rear-insert-deque!) rear-insert-deque!)
          ((eq? m 'front-delete-deque!) front-delete-deque!)
          ((eq? m 'rear-delete-deque!) rear-delete-deque!)
          ((eq? m 'display-deque) (display-deque))
          (else (error "invalid message for deque: " m))))
  dispatch)

(define (empty-deque? deque) (deque 'empty-deque?))
(define (front-deque deque) (deque 'front-deque))
(define (rear-deque deque) (deque 'rear-deque))
(define (front-insert-deque! deque item) ((deque 'front-insert-deque!) item))
(define (rear-insert-deque! deque item) ((deque 'rear-insert-deque!) item))
(define (front-delete-deque! deque) ((deque 'front-delete-deque!)))
(define (rear-delete-deque! deque) ((deque 'rear-delete-deque!)))
(define (display-deque deque) (deque 'display-deque))

(define deque (make-deque))

(empty-deque? deque)

(front-insert-deque! deque 15)

(rear-insert-deque! deque 1)

(empty-deque? deque)

(display-deque deque)

(rear-insert-deque! deque 10)

(front-delete-deque! deque)

(rear-delete-deque! deque)




