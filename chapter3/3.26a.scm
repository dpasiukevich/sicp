(define (make-tree eq lt gt)
  (define tree '())
  (define (new-tree entry left right) (list entry left right))
  (define (entry tree) (car tree))
  (define (left-branch tree) (cadr tree))
  (define (right-branch tree) (caddr tree))
  (define (search-by-key key tree)
    (cond ((null? tree) #f)
          ((eq key (car (entry tree))) (entry tree)) ; Sharing object to outside LUL
          ((lt key (car (entry tree))) (search-by-key key (left-branch tree)))
          ((gt key (car (entry tree))) (search-by-key key (right-branch tree)))))
  (define (insert el tree)
    (cond ((null? tree) (new-tree el '() '()))
          ((eq (car el) (car (entry tree)))
           (new-tree (cons (car el) (cdr el))
                     (left-branch tree)
                     (right-branch tree)))
          ((lt (car el) (car (entry tree)))
           (new-tree (entry tree)
                     (insert el (left-branch tree))
                     (right-branch tree)))
          ((gt (car el) (car (entry tree)))
           (new-tree (entry tree)
                     (left-branch tree)
                     (insert el (right-branch tree))))))
  (define (dispatch m)
    (cond ((eq? m 'insert) (lambda (el) (set! tree (insert el tree))))
          ((eq? m 'null?) (null? tree))
          ((eq? m 'search) (lambda (key) (search-by-key key tree)))
          ((eq? m 'print) tree)
          (else (error "Operation is not supported -- TREE" m))))
  dispatch)

(define (make-table same-key?)
  (define local-table (cons '*table* (make-tree = < >)))
  (define (assoc key records)
    (if (procedure? records)
        ((records 'search) key)
        #f))
  (define (lookup table)
    (lambda (keys)
      (if (null? keys) 
          #f
          (let ((record (assoc (car keys) (cdr table))) ; record is (cons key value)
                (rest-of-keys (cdr keys)))
            (cond ((eq? record #f) #f)
                  ((null? rest-of-keys) (if (procedure? (cdr record))
                                            ((cdr record) 'print)
                                            (cdr record)))
                  (else ((lookup record) rest-of-keys)))))))
  (define (insert! table)
    (lambda (keys value)
      (if (null? keys) (error "No keys -- INSERT!"))
      (define current-key (car keys))
      (define rest-of-keys (cdr keys))
      (define records (cdr table)) ; records is a binary tree
      (define record (assoc current-key records))
      (if record
          (cond ((null? rest-of-keys)
                 (set-cdr! record value)) ; update pair
                (else (cond ((procedure? (cdr record))
                             ((insert! record) rest-of-keys value))
                            (else (set-cdr! record (make-tree = < >))
                                  ((insert! record) rest-of-keys value)))))
          (cond ((null? rest-of-keys)
                 ((records 'insert) (cons current-key value))) ; create pair
                (else (let ((new-table (cons current-key (make-tree = < >))))
                        ((records 'insert) new-table)
                        ((insert! new-table) rest-of-keys value)))))))
  (define (dispatch m)
    (cond ((eq? m 'lookup-proc) (lookup local-table))
          ((eq? m 'insert-proc!) (insert! local-table))
          ((eq? m 'print) (print))
          (else (error "Unknown operation -- TABLE" m))))
  dispatch)

(define operation-table (make-table eq?))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

(define tr (make-tree = < >))
((tr 'search) 3)
((tr 'insert) (cons 5 2))
((tr 'insert) (cons 1 2))
((tr 'insert) (cons 4 5))
((tr 'insert) (cons 4 6))
((tr 'insert) (cons 2 3))
((tr 'insert) (cons 6 3))
(tr 'print)
((tr 'search) 4)
((tr 'search) 2)
((tr 'search) 324)


(define t (make-table equal?))
((t 'insert-proc!) (list 1 2) 'test-value)
((t 'insert-proc!) (list 1 3 2 4) 'lul)
((t 'insert-proc!) (list 1 2 3) 'lul1)
((t 'insert-proc!) (list 2) 'lul1)
((t 'insert-proc!) (list 3) 'lul1)
((t 'insert-proc!) (list 4) 'lul1)
((t 'insert-proc!) (list 5) 'lul1)
((t 'insert-proc!) (list 6) 'lul1)
((t 'insert-proc!) (list 9) 'lul1)

((t 'lookup-proc) (list 1 2))
((t 'insert-proc!) (list 2) 2)
((t 'insert-proc!) (list 2 3) 14)
((t 'insert-proc!) (list 2 2) 14)
((t 'insert-proc!) (list 1 2) 14)
((t 'insert-proc!) (list 1) 14)
((t 'insert-proc!) (list 1 2 3 4) 14)
((t 'insert-proc!) (list 1 3 3 4) 14)
((t 'lookup-proc) (list 1))
((t 'lookup-proc) (list 1 2 3 4))

((t 'lookup-proc) (list 9))


