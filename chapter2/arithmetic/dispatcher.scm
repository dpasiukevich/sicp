(define (apply-generic op . args)
  (define (build-ranks tower)
    (define (iter type-list index hash-table)
      (cond ((null? type-list) hash-table)
            (else (hash-table-set! hash-table (car type-list) index)
                  (iter (cdr type-list) (+ index 1) hash-table))))
    (iter tower 0 (make-hash-table)))
  (define ranks (build-ranks '(scheme-number rational real complex)))
  (define (max-in-list l)
    (define (iter list-head result)
      (if (null? list-head) 
          result
          (iter (cdr list-head) (max result (car list-head)))))
    (iter l -1))
  (define (func-apply func times arg)
    (cond ((= times 0) arg)
          (else (func-apply func (- times 1) (func arg)))))
  (define (coerce-by-ranks type-tags args)
    (let ((type-ranks (map (lambda (type) (hash-table/get ranks type -1)) type-tags)))
     (let ((max-rank (max-in-list type-ranks)))
      (if (every (lambda (rank) (= rank max-rank)) type-ranks)
          (error "No method for these types" (list op type-tags))
          (map (lambda (rank arg) (func-apply raise-num (- max-rank rank) arg)) type-ranks args)))))
  (let ((type-tags (map type-tag args)))
   (let ((proc (get op type-tags)))
    (if proc
        (if (memq op '(add sub mul div make))
            (drop (apply proc (map contents args))) 
            (apply proc (map contents args)))
        (apply apply-generic (cons op (coerce-by-ranks type-tags args)))))))

(define (attach-tag type-tag contents)
  (cond ((exact-integer? contents) contents)
        ((real? contents) contents)
        (else (cons type-tag contents))))

(define (type-tag datum)
  (cond ((exact-integer? datum) 'scheme-number) 
        ((real? datum) 'real)
        ((pair? datum) (car datum))
        (else (error "bad tagged datum: TYPE-TAG" datum))))

(define (contents datum)
  (cond ((exact-integer? datum) datum)
        ((real? datum) datum)
        ((pair? datum) (cdr datum))
        (else (error "Bad tagged datum: CONTENTS" datum))))

